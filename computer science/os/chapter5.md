# 操作系统 第五章 进程管理

## 进程描述

进程：一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。

### 进程与程序的联系

1. 程序是产生进程的基础

2. 程序的每次运行构成不同的进程

3. 进程是程序功能的体现

4. 通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。

5. 进程是动态的，程序是静态的；程序是有序代码的集合；进程是程序的执行，进程有核心态/用户态。

6. 进程是暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存。

7. 进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程状态信息）

### 进程的特点

动态性：可动态地创建、结束进程

并发性：进程可以被独立调度并占用处理机运行：并发并行

独立性：不同进程的工作不相互影响

制约性：因访问共享数据/资源或进程间同步而产生制约。

程序 = 算法 + 数据结构

#### PCB

描述进程的数据结构：进程控制块（Process Control Block， PCB），操作系统为每个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息。

PCB含有以下三大类信息

1. 进程表示信息。如本进程的标识，本进程的产生者标识（父标识），用户标识

2. 处理机状态信息保存区
    - 用户可见寄存器
    - 控制和状态寄存器
    - 栈指针

3. 进程控制信息

    - 调度和状态信息
    - 进程间通信信息
    - 存储管理信息
    - 进程所用资源
    - 有关数据结构连结信息

PCB的组织方式：链表，索引表

## 进程状态

### 进程的生命期管理

#### 进程创建

1. 系统初始化时
2. 用户请求创建一个新进程
3. 正在运行的进程执行了创建进程的系统调用

#### 进程运行

内存选择一个就绪的进程，让他占用处理机并执行

#### 进程等待

在以下情况下，进程等待（阻塞）

1. 请求并等待系统服务，无法马上完成
2. 启动某种操作，无法马上完成
3. 需要的数据没有到达

进程只能自己阻塞自己。

#### 进程唤醒

唤醒进程的原因：

1. 被阻塞进程需要的资源可被满足
2. 被阻塞进程等待的事件到达
3. 将该进程的PCB插入到就绪队列。

进程只能被别的进程或操作新系统唤醒。

#### 进程结束

在以下四种情形下，进程结束

1. 正常退出（自愿的）
2. 错误退出（自愿的）
3. 致命错误（强制性的）
4. 被其他进程所杀（强制性的）

### 进程状态变化模型

进程的三种基本状态：

- 运行状态

- 就绪状态

- 等待状态

### 进程挂起（Suspend）

进程在挂起状态时，意味着进程没有占用内存空。处于挂起状态的进程映像在磁盘上。

- 挂起：把一个进程从内存转到外存，可能有以下几种情况
    - 阻塞到阻塞挂起
    - 就绪到就绪挂起
    - 运行到就绪挂起
- 在外存时的状态转换
    - 阻塞挂起到就绪挂起：当有阻塞挂起进程因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程。
- 解卦/激活：把一个进程从外存转到内存
    - 就绪挂起到就绪
    - 阻塞挂起到阻塞

#### 状态队列

由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态

不同的状态分别用不同的队列来表示

每个几次呢很难过的PCB都根据它的状态加入到相应的队列当中

## 线程（Thread）管理

自从60年代提出进程概念以来，在操作系统中一直都是以进程作为独立运行的基本单位，直到80年代中期，人们又提出了更小的能独立运行的基本单位——线程。

- 需要提出以中国新的实体，满足以下特性：
    - 实体之间可以并发地执行
    - 实体之间共享同一块内存空间

### 线程定义

进程当中的一条执行流程

从资源组合的角度：进程把一组相关的资源组合起来，构成了一个资源平台（环境），包括地址空间（代码段，数据段）、打开的文件等各种资源。

从运行的角度：代码在这个资源平台上的一条执行流程（线程）。

- 线程的优点：
    - 一个进程中可以同时存在多个线程
    - 各个线程之间可以并发地执行
    - 各个线程之间可以共享地址空间和文件等资源
- 线程的缺点：
    - 一个线程崩溃，会导致其所属进程的所有线程崩溃。

### 线程与进程的比较

- 进程时资源分配单位，线程是CPU调度单位
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈
- 线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系
- 线程能减少并发执行的时间和空间开销
    - 线程的创建时间比进程短
    - 线程的终止时间比进程短
    - 同一进程的线程切换时间比进程短
    - 由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信。

### 线程的实现

主要有三种线程的实现方式：

- 用户线程：在用户空间实现
- 内核线程：在内核中实现
    - Windows
- 轻量级进程：在内核中实现，支持用户线程（内核支持的用户线程）
    - Solaris，Linux

## 进程控制

### 上下文切换

- 操作系统为活跃进程准备了进程控制块（PCB）
- 操作系统将几次呢还给你控制块（PCB）放置在一个合适的队列里
    - 就绪队列
    - 等待I/O队列（每个设备的队列）
    - 僵尸队列

### 创建进程

- fork()的简单实现
- 在99%的情况里，我们在调用fork()之后调用exec()
- vfork()
    - 一个创建进程的系统调用，不需要创建一个同样的内存映像
    - 一些时候称为轻量级fork()
    - 紫禁城应该几乎立即调用exec()
    - 可以采用COW Copy on Write技术

### 等待/中止进程

wait()系统嗲用是被父进程用来等待子进程的结束

- 一个子进程向父进程返回一个值，所以父进程必须接受这个值并处理
- wait()系统调用担任这个要求
- 进程结束执行之后，它调用exit()
    - 将这程序的“结果”作为一个参数
    - 关闭所有打开的文件，连接等等
    - 释放内存
    - 释放大部分支持进程的操作系统结构
    - 检查是否父进程是存活者的
        - 如果是的话，它保留结果的值知道父进程需要它；在这种情况里，进程没有真正死亡，但是它进入了僵尸（zombie/defunct）状态
        - 如果没有，它释放所有的数据结构，这个进程死亡
    - 清理所有等待的僵尸进程
- 进程终止是最终的垃圾收集（资源回收）