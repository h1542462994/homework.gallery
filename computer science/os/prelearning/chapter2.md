# 操作系统 第二章 启动、中断、异常和系统调用

## 启动

启动环节涉及到的资源：CPU，IO和Memory。

DISK：存放OS
BIOS：基本I/O处理系统
Bootloader：POST（加电自检），寻找显卡和执行BIOS，加载OS，Bootloader一般放在硬盘的第一个主引导扇区
CS:IP=0xf000:fff0

启动过程：

1. BIOS将Bootloader加载到内存中，并将控制权交给bootloader
2. Bootloader：将操作系统的数据和代码从硬盘加载到内存中。

操作系统与设备和程序的交互：

1. 系统调用、异常和中断。
2. 系统调用：应用系统主动向操作系统发出服务请求；异常：非法指令或者其他坏的处理状态；中断：来自不同的硬件设备的计时器和网络的中断。
3. 在计算机运行中，内核是被信任的第三方。只有内核可以执行特权指令。为了方便应用程序。

系统调用、异常和中断区别：

- 源头
    - 中断：外设 
    - 异常：应用系统意料不到的行为
    - 系统调用：应用系统请求操作提供服务
- 处理时间
    - 中断：异步
    - 异常：同步
    - 系统调用：异步或同步
- 响应
    - 中断：持续，对用户应用程序是透明的
    - 异常：杀死或者重新执行意想不到的应用程序指令
    - 系统调用：等待和持续

## 中断、异常和系统调用

### 中断和异常的处理机制

- 中断是外设的事件
- 异常是内部CPU的事件
- 中断和异常迫使CPU访问一些被中断和异常服务访问的功能

#### 硬件

- **设置中断标记[CPU初始化]**
    - 将内部、外部事件设置中断标记
    - 中断事件的ID

#### 软件

- 保存当前处理状态
- 中断服务程序处理
- **清除中断标记**
- 恢复之前保存的处理状态

#### 异常

- 保存现场
- 异常处理
    - 杀死产生了异常的程序
    - 重新执行异常指令
- 恢复现场

### 系统调用

- 访问程序主要是通过高层次的API接口而不是直接进行系统调用。
    - Win32 API 用于Windows
    - POSIX API 用于POSIX-based systems
    - Java API用于JAVA虚拟机
- user mode和kernel mode
    - 控制权从应用系统转到操作系统（特权级转换）即用户态到内核态
    - 函数调用是使用同一堆栈
    - 系统调用使用不同的堆栈
- 跨越操作系统边界的开销
    - 在执行时间上的开销超过程序调用
    - 开销：
        - 建立中断/异常/系统调用号与对应服务，**例程映射关系的初始化开销**
        - 建立内核堆栈
        - 验证参数
        - 内核态映射到用户态的地址空间 更新页面映射权限
        - 内核态独立地址空间 TLB
        - **cache和tlb**
